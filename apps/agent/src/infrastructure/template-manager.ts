/**
 * @file apps/agent/src/infrastructure/template-manager.ts
 * @description Gestionnaire de templates pour les fichiers de configuration.
 * Ce fichier permet de centraliser et de gérer les templates de configuration
 * des services, facilitant leur maintenance et leur versionnement.
 *
 * Syntaxe des templates :
 * - Variables : {{ variableName }}
 * - Valeur par défaut : {{ variableName | default:valeur }}
 * - Conditions : {{#if variableName}}contenu{{/if}}
 * - Conditions négatives : {{#unless variableName}}contenu{{/unless}}
 * - Boucles : {{#each items}}{{ item }}{{/each}}
 *
 * @fonctions_principales
 * - loadTemplate() : Charge un template depuis le système de fichiers ou embarqué
 * - renderTemplate() : Rend un template avec des variables
 * - writeConfig() : Écrit un fichier de configuration depuis un template
 */

import fs from 'node:fs';
import path from 'node:path';

/**
 * Variables disponibles pour les templates
 */
export interface TemplateVariables {
    [key: string]: string | number | boolean | string[] | TemplateVariables | undefined;
}

/**
 * Options pour l'écriture de fichiers de configuration
 */
export interface WriteConfigOptions {
    /** Mode du fichier (permissions Unix, ex: 0o644) */
    mode?: number;
    /** Ajouter au fichier existant au lieu de le remplacer */
    append?: boolean;
    /** Créer les répertoires parents si nécessaire */
    createDirs?: boolean;
    /** Propriétaire du fichier (user:group) */
    owner?: string;
}

/**
 * Templates embarqués (pour les configurations courantes)
 * Ces templates sont compilés dans le bundle et disponibles sans fichier externe.
 */
const EMBEDDED_TEMPLATES: Record<string, string> = {
    // ============================================
    // FAIL2BAN
    // ============================================
    'fail2ban/jail.local': `# Fail2ban configuration - Generated by ServerFlow
# Do not edit manually - changes will be overwritten

[DEFAULT]
bantime = {{ bantime | default:1h }}
findtime = {{ findtime | default:10m }}
maxretry = {{ maxretry | default:5 }}

[sshd]
enabled = true
port = {{ ssh_port | default:ssh }}
logpath = /var/log/auth.log
maxretry = {{ ssh_maxretry | default:3 }}
`,

    // ============================================
    // UFW
    // ============================================
    'ufw/rules': `# UFW Rules - Generated by ServerFlow
# Applied automatically during installation

# Default policies
default deny incoming
default allow outgoing

# Allowed services
{{#each allowed_ports}}
allow {{ port }}
{{/each}}
`,

    // ============================================
    // BIND9 / DNS
    // ============================================
    'bind9/named.conf.options': `// BIND9 DNS Server Options - Generated by ServerFlow
// Do not edit manually - changes will be overwritten

options {
    directory "/var/cache/bind";

    // Forward queries to public DNS if not authoritative
    forwarders {
        {{ forwarder1 | default:8.8.8.8 }};
        {{ forwarder2 | default:8.8.4.4 }};
        {{ forwarder3 | default:1.1.1.1 }};
    };

    dnssec-validation auto;

    // Listen on local interfaces
    listen-on { {{ listen_on | default:any }}; };
    listen-on-v6 { {{ listen_on_v6 | default:any }}; };

    // Allow queries from local network
    allow-query { {{ allow_query | default:localhost; localnets }}; };

    // Recursion settings (security)
    recursion {{ recursion | default:yes }};
    allow-recursion { {{ allow_recursion | default:localhost; localnets }}; };
};
`,

    // ============================================
    // POSTFIX
    // ============================================
    'postfix/main.cf': `# Postfix Main Configuration - Generated by ServerFlow
# Appended to existing configuration

# Basic settings
myhostname = {{ hostname }}
mydomain = {{ domain }}
myorigin = $mydomain
mydestination = $myhostname, localhost.$mydomain, localhost
mynetworks = {{ mynetworks | default:127.0.0.0/8 [::ffff:127.0.0.0]/104 [::1]/128 }}

# TLS parameters
smtpd_tls_cert_file={{ tls_cert | default:/etc/ssl/certs/ssl-cert-snakeoil.pem }}
smtpd_tls_key_file={{ tls_key | default:/etc/ssl/private/ssl-cert-snakeoil.key }}
smtpd_tls_security_level=may
smtp_tls_security_level=may

# SASL authentication
smtpd_sasl_type = dovecot
smtpd_sasl_path = private/auth
smtpd_sasl_auth_enable = yes

# Restrictions
smtpd_recipient_restrictions =
    permit_mynetworks,
    permit_sasl_authenticated,
    reject_unauth_destination,
    reject_rbl_client zen.spamhaus.org

# Mailbox
home_mailbox = Maildir/

# Size limits
message_size_limit = {{ message_size_limit | default:52428800 }}
mailbox_size_limit = {{ mailbox_size_limit | default:0 }}

# Virtual domains (uncomment and configure as needed)
# virtual_mailbox_domains = /etc/postfix/virtual_domains
# virtual_mailbox_base = /var/mail/vhosts
# virtual_mailbox_maps = hash:/etc/postfix/vmailbox
# virtual_alias_maps = hash:/etc/postfix/virtual
`,

    'postfix/master.cf.spf': `
# SPF Policy Daemon - Generated by ServerFlow
policyd-spf  unix  -       n       n       -       0       spawn
    user=policyd-spf argv=/usr/bin/policyd-spf
`,

    // ============================================
    // DOVECOT
    // ============================================
    'dovecot/local.conf': `# Dovecot Local Configuration - Generated by ServerFlow
# Do not edit manually - changes will be overwritten

# Mailbox location
mail_location = maildir:~/Maildir

# Authentication
auth_mechanisms = plain login

# SSL/TLS
ssl = yes
ssl_cert = <{{ ssl_cert | default:/etc/ssl/certs/ssl-cert-snakeoil.pem }}
ssl_key = <{{ ssl_key | default:/etc/ssl/private/ssl-cert-snakeoil.key }}

# Protocols
protocols = {{ protocols | default:imap pop3 lmtp }}

# LMTP socket for Postfix
service lmtp {
  unix_listener /var/spool/postfix/private/dovecot-lmtp {
    mode = 0600
    user = postfix
    group = postfix
  }
}

# Auth socket for Postfix SASL
service auth {
  unix_listener /var/spool/postfix/private/auth {
    mode = 0660
    user = postfix
    group = postfix
  }
}

# Logging
log_path = {{ log_path | default:/var/log/dovecot.log }}
info_log_path = {{ info_log_path | default:/var/log/dovecot-info.log }}
`,

    // ============================================
    // RSPAMD
    // ============================================
    'rspamd/worker-proxy.inc': `# Rspamd milter for Postfix - Generated by ServerFlow
milter = yes;
bind_socket = "{{ socket_path | default:/var/spool/postfix/rspamd/rspamd.sock }} mode={{ socket_mode | default:0666 }} owner={{ socket_owner | default:_rspamd }}";
`,

    'rspamd/antivirus.conf': `# ClamAV integration for Rspamd - Generated by ServerFlow
clamav {
    scan_mime_parts = {{ scan_mime_parts | default:true }};
    servers = "{{ clamav_socket | default:/var/run/clamav/clamd.sock }}";
    symbol = "CLAM_VIRUS";
    patterns {
        JUST_EICAR = "^Eicar-Test-Signature$";
    }
}
`,

    // ============================================
    // OPENDKIM
    // ============================================
    'opendkim/opendkim.conf': `# OpenDKIM Configuration - Generated by ServerFlow
# Do not edit manually - changes will be overwritten

AutoRestart             Yes
AutoRestartRate         10/1h
Syslog                  yes
SyslogSuccess           Yes
LogWhy                  Yes

Canonicalization        relaxed/simple

ExternalIgnoreList      refile:/etc/opendkim/TrustedHosts
InternalHosts           refile:/etc/opendkim/TrustedHosts
KeyTable                refile:/etc/opendkim/KeyTable
SigningTable            refile:/etc/opendkim/SigningTable

Mode                    sv
PidFile                 /var/run/opendkim/opendkim.pid
SignatureAlgorithm      rsa-sha256

UserID                  opendkim:opendkim

Socket                  inet:{{ port | default:12301 }}@{{ bind | default:localhost }}
`,

    'opendkim/TrustedHosts': `# OpenDKIM Trusted Hosts - Generated by ServerFlow
127.0.0.1
localhost
{{ hostname }}
*.{{ domain }}
`,

    'opendkim/KeyTable': `# OpenDKIM Key Table - Generated by ServerFlow
default._domainkey.{{ domain }} {{ domain }}:default:{{ keys_dir }}/default.private
`,

    'opendkim/SigningTable': `# OpenDKIM Signing Table - Generated by ServerFlow
*@{{ domain }} default._domainkey.{{ domain }}
`,

    // ============================================
    // CLAMAV
    // ============================================
    'clamav/clamd.conf': `# ClamAV Daemon Configuration - Generated by ServerFlow
# Optimized for Mail Server usage

LocalSocket {{ socket | default:/var/run/clamav/clamd.sock }}
LocalSocketGroup {{ socket_group | default:clamav }}
LocalSocketMode {{ socket_mode | default:666 }}
FixStaleSocket true
User {{ user | default:clamav }}
ScanMail true
ScanArchive true
MaxFileSize {{ max_file_size | default:25M }}
MaxScanSize {{ max_scan_size | default:100M }}
StreamMaxLength {{ stream_max_length | default:25M }}
LogFile {{ log_file | default:/var/log/clamav/clamav.log }}
LogTime true
LogVerbose false
PidFile {{ pid_file | default:/var/run/clamav/clamd.pid }}
DatabaseDirectory {{ db_dir | default:/var/lib/clamav }}
`,

    // ============================================
    // NGINX (exemples de base)
    // ============================================
    'nginx/server-block': `# Nginx Server Block - Generated by ServerFlow
server {
    listen {{ port | default:80 }};
    listen [::]:{{ port | default:80 }};
    server_name {{ server_name }};

    root {{ root | default:/var/www/html }};
    index index.html index.htm index.php;

    location / {
        try_files $uri $uri/ =404;
    }

    {{#if php_enabled}}
    location ~ \\.php$ {
        include snippets/fastcgi-php.conf;
        fastcgi_pass unix:/var/run/php/php-fpm.sock;
    }
    {{/if}}

    {{#if ssl_enabled}}
    listen 443 ssl;
    listen [::]:443 ssl;
    ssl_certificate {{ ssl_cert }};
    ssl_certificate_key {{ ssl_key }};
    {{/if}}
}
`,

    'nginx/proxy-pass': `# Nginx Reverse Proxy - Generated by ServerFlow
server {
    listen {{ port | default:80 }};
    listen [::]:{{ port | default:80 }};
    server_name {{ server_name }};

    location / {
        proxy_pass {{ backend_url }};
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_cache_bypass $http_upgrade;
    }
}
`,

    // ============================================
    // REDIS
    // ============================================
    'redis/redis.conf.security': `# Redis Security Configuration - Generated by ServerFlow
# Append to /etc/redis/redis.conf

# Password authentication
requirepass {{ password }}

# Bind to localhost only
bind {{ bind | default:127.0.0.1 ::1 }}

# Protected mode
protected-mode {{ protected_mode | default:yes }}
`,

    // ============================================
    // HAPROXY
    // ============================================
    'haproxy/haproxy.cfg': `# HAProxy Configuration - Generated by ServerFlow
global
    log /dev/log    local0
    log /dev/log    local1 notice
    chroot /var/lib/haproxy
    stats socket /run/haproxy/admin.sock mode 660 level admin
    stats timeout 30s
    user haproxy
    group haproxy
    daemon

    # SSL settings
    ssl-default-bind-ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256
    ssl-default-bind-ciphersuites TLS_AES_128_GCM_SHA256:TLS_AES_256_GCM_SHA384
    ssl-default-bind-options ssl-min-ver TLSv1.2 no-tls-tickets

defaults
    log     global
    mode    http
    option  httplog
    option  dontlognull
    timeout connect {{ timeout_connect | default:5000 }}
    timeout client  {{ timeout_client | default:50000 }}
    timeout server  {{ timeout_server | default:50000 }}
    errorfile 400 /etc/haproxy/errors/400.http
    errorfile 403 /etc/haproxy/errors/403.http
    errorfile 408 /etc/haproxy/errors/408.http
    errorfile 500 /etc/haproxy/errors/500.http
    errorfile 502 /etc/haproxy/errors/502.http
    errorfile 503 /etc/haproxy/errors/503.http
    errorfile 504 /etc/haproxy/errors/504.http

# Stats page
listen stats
    bind *:{{ stats_port | default:8404 }}
    stats enable
    stats uri /stats
    stats refresh 10s
    stats admin if LOCALHOST

# Frontend
frontend {{ frontend_name | default:http_front }}
    bind *:{{ frontend_port | default:80 }}
    default_backend {{ backend_name | default:servers }}

# Backend
backend {{ backend_name | default:servers }}
    balance {{ balance | default:roundrobin }}
    option httpchk GET /
    {{#each servers}}
    server {{ name }} {{ address }}:{{ port }} check
    {{/each}}
`,
};

/**
 * **TemplateManager** - Gestionnaire de templates de configuration
 *
 * Cette classe permet de :
 * - Charger des templates embarqués ou depuis le système de fichiers
 * - Rendre des templates avec des variables
 * - Écrire des fichiers de configuration
 */
export class TemplateManager {
    private templatesDir: string;

    /**
     * @param templatesDir - Répertoire optionnel pour les templates personnalisés
     */
    constructor(templatesDir?: string) {
        this.templatesDir = templatesDir || path.join(__dirname, 'templates');
    }

    /**
     * **loadTemplate()** - Charge un template
     *
     * Cherche d'abord dans les templates personnalisés, puis dans les templates embarqués.
     *
     * @param name - Nom du template (ex: 'postfix/main.cf')
     * @returns Le contenu du template
     * @throws Error si le template n'existe pas
     */
    loadTemplate(name: string): string {
        // 1. Chercher dans le répertoire de templates personnalisés
        const customPath = path.join(this.templatesDir, name);
        if (fs.existsSync(customPath)) {
            return fs.readFileSync(customPath, 'utf-8');
        }

        // 2. Chercher dans les templates embarqués
        if (EMBEDDED_TEMPLATES[name]) {
            return EMBEDDED_TEMPLATES[name];
        }

        throw new Error(`Template not found: ${name}`);
    }

    /**
     * **hasTemplate()** - Vérifie si un template existe
     */
    hasTemplate(name: string): boolean {
        const customPath = path.join(this.templatesDir, name);
        return fs.existsSync(customPath) || !!EMBEDDED_TEMPLATES[name];
    }

    /**
     * **listTemplates()** - Liste tous les templates disponibles
     */
    listTemplates(): string[] {
        const templates = new Set<string>(Object.keys(EMBEDDED_TEMPLATES));

        // Ajouter les templates personnalisés
        if (fs.existsSync(this.templatesDir)) {
            this.listFilesRecursive(this.templatesDir, '').forEach(t => templates.add(t));
        }

        return Array.from(templates).sort();
    }

    private listFilesRecursive(dir: string, prefix: string): string[] {
        const files: string[] = [];
        if (!fs.existsSync(dir)) return files;

        for (const entry of fs.readdirSync(dir, { withFileTypes: true })) {
            const fullPath = path.join(dir, entry.name);
            const relativePath = prefix ? `${prefix}/${entry.name}` : entry.name;

            if (entry.isDirectory()) {
                files.push(...this.listFilesRecursive(fullPath, relativePath));
            } else {
                files.push(relativePath);
            }
        }
        return files;
    }

    /**
     * **renderTemplate()** - Rend un template avec des variables
     *
     * Syntaxe supportée :
     * - {{ variable }} : Remplace par la valeur de la variable
     * - {{ variable | default:valeur }} : Utilise la valeur par défaut si la variable n'existe pas
     * - {{#if variable}}...{{/if}} : Condition
     * - {{#unless variable}}...{{/unless}} : Condition négative
     * - {{#each items}}...{{ item }}...{{/each}} : Boucle
     *
     * @param template - Contenu du template
     * @param variables - Variables à substituer
     * @returns Le template rendu
     */
    renderTemplate(template: string, variables: TemplateVariables): string {
        let result = template;

        // 1. Traiter les conditions {{#if variable}}...{{/if}}
        result = this.processConditions(result, variables);

        // 2. Traiter les conditions négatives {{#unless variable}}...{{/unless}}
        result = this.processUnless(result, variables);

        // 3. Traiter les boucles {{#each items}}...{{/each}}
        result = this.processLoops(result, variables);

        // 4. Traiter les variables {{ variable | default:value }}
        result = this.processVariables(result, variables);

        return result;
    }

    private processConditions(template: string, variables: TemplateVariables): string {
        // Regex pour {{#if variable}}...{{/if}} (non-greedy)
        const ifRegex = /\{\{#if\s+(\w+)\}\}([\s\S]*?)\{\{\/if\}\}/g;

        return template.replace(ifRegex, (_, varName, content) => {
            const value = this.getNestedValue(variables, varName);
            // Considère truthy : existe et n'est pas false, '', 0, null, undefined
            if (value && value !== 'false' && value !== '0') {
                return content;
            }
            return '';
        });
    }

    private processUnless(template: string, variables: TemplateVariables): string {
        // Regex pour {{#unless variable}}...{{/unless}}
        const unlessRegex = /\{\{#unless\s+(\w+)\}\}([\s\S]*?)\{\{\/unless\}\}/g;

        return template.replace(unlessRegex, (_, varName, content) => {
            const value = this.getNestedValue(variables, varName);
            // Inverse de if
            if (!value || value === 'false' || value === '0') {
                return content;
            }
            return '';
        });
    }

    private processLoops(template: string, variables: TemplateVariables): string {
        // Regex pour {{#each items}}...{{/each}}
        const eachRegex = /\{\{#each\s+(\w+)\}\}([\s\S]*?)\{\{\/each\}\}/g;

        return template.replace(eachRegex, (_, varName, content) => {
            const items = this.getNestedValue(variables, varName);

            if (!Array.isArray(items)) {
                return '';
            }

            return items.map((item, index) => {
                // Créer un contexte pour chaque itération
                let itemContent = content;

                if (typeof item === 'object' && item !== null) {
                    // Si l'item est un objet, remplacer {{ prop }} par les propriétés
                    for (const [key, val] of Object.entries(item)) {
                        const propRegex = new RegExp(`\\{\\{\\s*${key}\\s*\\}\\}`, 'g');
                        itemContent = itemContent.replace(propRegex, String(val ?? ''));
                    }
                } else {
                    // Si l'item est une valeur simple, remplacer {{ item }}
                    itemContent = itemContent.replace(/\{\{\s*item\s*\}\}/g, String(item));
                }

                // Ajouter l'index
                itemContent = itemContent.replace(/\{\{\s*@index\s*\}\}/g, String(index));

                return itemContent;
            }).join('');
        });
    }

    private processVariables(template: string, variables: TemplateVariables): string {
        // Regex pour {{ variable }} et {{ variable | default:value }}
        const varRegex = /\{\{\s*(\w+(?:\.\w+)*)\s*(?:\|\s*default:([^}]+))?\s*\}\}/g;

        return template.replace(varRegex, (_, varPath, defaultValue) => {
            const value = this.getNestedValue(variables, varPath);

            if (value !== undefined && value !== null && value !== '') {
                return String(value);
            }

            if (defaultValue !== undefined) {
                return defaultValue.trim();
            }

            return '';
        });
    }

    private getNestedValue(obj: TemplateVariables, path: string): any {
        const parts = path.split('.');
        let current: any = obj;

        for (const part of parts) {
            if (current === null || current === undefined) {
                return undefined;
            }
            current = current[part];
        }

        return current;
    }

    /**
     * **render()** - Raccourci pour charger et rendre un template
     *
     * @param templateName - Nom du template
     * @param variables - Variables à substituer
     * @returns Le template rendu
     */
    render(templateName: string, variables: TemplateVariables): string {
        const template = this.loadTemplate(templateName);
        return this.renderTemplate(template, variables);
    }

    /**
     * **writeConfig()** - Écrit un fichier de configuration depuis un template
     *
     * @param templateName - Nom du template
     * @param targetPath - Chemin du fichier de destination
     * @param variables - Variables à substituer
     * @param options - Options d'écriture
     */
    writeConfig(
        templateName: string,
        targetPath: string,
        variables: TemplateVariables,
        options: WriteConfigOptions = {}
    ): void {
        const content = this.render(templateName, variables);

        // Créer les répertoires parents si nécessaire
        if (options.createDirs !== false) {
            const dir = path.dirname(targetPath);
            if (!fs.existsSync(dir)) {
                fs.mkdirSync(dir, { recursive: true });
            }
        }

        // Écrire le fichier
        if (options.append) {
            fs.appendFileSync(targetPath, content, { mode: options.mode });
        } else {
            fs.writeFileSync(targetPath, content, { mode: options.mode });
        }

        // Changer le propriétaire si spécifié (Linux uniquement)
        if (options.owner && process.platform !== 'win32') {
            const [user, group] = options.owner.split(':');
            try {
                const { execSync } = require('child_process');
                execSync(`chown ${user}:${group || user} "${targetPath}"`);
            } catch {
                // Ignorer si on n'a pas les permissions
            }
        }
    }

    /**
     * **renderToString()** - Rend un template et retourne le résultat sans écrire de fichier
     *
     * Utile pour prévisualiser le résultat ou pour des cas où on veut
     * manipuler le contenu avant de l'écrire.
     */
    renderToString(templateName: string, variables: TemplateVariables): string {
        return this.render(templateName, variables);
    }
}

/**
 * Instance globale du gestionnaire de templates
 */
export const templateManager = new TemplateManager();

/**
 * Fonction utilitaire pour rendre un template rapidement
 */
export function renderConfig(templateName: string, variables: TemplateVariables): string {
    return templateManager.render(templateName, variables);
}

/**
 * Fonction utilitaire pour écrire une configuration rapidement
 */
export function writeConfig(
    templateName: string,
    targetPath: string,
    variables: TemplateVariables,
    options?: WriteConfigOptions
): void {
    templateManager.writeConfig(templateName, targetPath, variables, options);
}
