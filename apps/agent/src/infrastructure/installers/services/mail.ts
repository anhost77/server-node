/**
 * @file apps/agent/src/infrastructure/installers/services/mail.ts
 * @description Installation des services de messagerie.
 * Ce fichier contient les fonctions pour installer la stack mail compl√®te :
 * Postfix (MTA), Dovecot (IMAP/POP3), Rspamd (antispam), OpenDKIM, ClamAV.
 *
 * @fonctions_principales
 * - installPostfix() : Installe le serveur SMTP Postfix
 * - installDovecot() : Installe le serveur IMAP/POP3 Dovecot
 * - installRspamd() : Installe l'antispam Rspamd
 * - installOpendkim() : Installe OpenDKIM pour la signature des emails
 * - installClamav() : Installe l'antivirus ClamAV
 * - installSpfPolicyd() : Installe le SPF Policy Daemon
 */

import fs from 'node:fs';
import os from 'node:os';
import type { LogFn } from '../../types.js';
import { runCommand, runCommandSilent, getCommandVersion, prepareServiceReinstall, regenerateConfigIfMissing } from '../../helpers.js';
import { writeConfig } from '../../template-manager.js';

/**
 * **installPostfix()** - Installe le serveur SMTP Postfix
 *
 * Cette fonction g√®re intelligemment les cas suivants :
 * - R√©installation apr√®s une d√©sinstallation
 * - Fichiers de configuration manquants apr√®s un purge
 *
 * @param onLog - Fonction de logging
 * @param mailConfig - Configuration mail optionnelle (domaine, hostname)
 */
export async function installPostfix(onLog: LogFn, mailConfig?: { domain: string; hostname: string }): Promise<string> {
    onLog(`üì• Installing Postfix MTA...\n`, 'stdout');

    // Utiliser la config fournie ou d√©duire du hostname syst√®me
    let hostname: string;
    let domain: string;

    if (mailConfig) {
        hostname = mailConfig.hostname;
        domain = mailConfig.domain;
        onLog(`   üìß Using configured domain: ${domain}, hostname: ${hostname}\n`, 'stdout');
    } else {
        hostname = os.hostname();
        domain = hostname.includes('.') ? hostname.split('.').slice(1).join('.') : hostname;
    }

    const postfixPackages = ['postfix', 'postfix-policyd-spf-python', 'libsasl2-modules'];

    // √âtape 0 : Nettoyage des installations pr√©c√©dentes
    await prepareServiceReinstall('postfix', postfixPackages, 'postfix', onLog);

    // Pre-configure postfix to avoid interactive prompts
    const debconfSelections = `postfix postfix/main_mailer_type select Internet Site
postfix postfix/mailname string ${hostname}
postfix postfix/destinations string ${hostname}, ${domain}, localhost.localdomain, localhost
`;
    fs.writeFileSync('/tmp/postfix-debconf', debconfSelections);
    await runCommand('bash', ['-c', 'debconf-set-selections < /tmp/postfix-debconf'], onLog);
    await runCommandSilent('rm', ['/tmp/postfix-debconf']);

    await runCommand('apt-get', ['update'], onLog);
    await runCommand('apt-get', ['install', '-y', ...postfixPackages], onLog);

    // Basic secure configuration using template
    writeConfig('postfix/main.cf', '/etc/postfix/main.cf', {
        hostname,
        domain
    }, { append: true });

    await runCommand('systemctl', ['enable', 'postfix'], onLog);
    await runCommand('systemctl', ['restart', 'postfix'], onLog);

    onLog(`‚úÖ Postfix installed for ${domain}. Configure TLS certificates for production use.\n`, 'stdout');
    const version = await getCommandVersion('postconf', ['mail_version']);
    return version?.replace('mail_version = ', '').trim() || 'installed';
}

/**
 * **installDovecot()** - Installe le serveur IMAP/POP3 Dovecot
 *
 * Cette fonction g√®re intelligemment les cas suivants :
 * - R√©installation apr√®s une d√©sinstallation (nettoie les fichiers corrompus)
 * - Fichiers de configuration manquants apr√®s un purge
 * - Cache debconf corrompu
 */
export async function installDovecot(onLog: LogFn): Promise<string> {
    onLog(`üì• Installing Dovecot IMAP/POP3 Server...\n`, 'stdout');

    const dovecotPackages = ['dovecot-core', 'dovecot-imapd', 'dovecot-pop3d', 'dovecot-lmtpd', 'dovecot-sieve'];

    // √âtape 0 : Nettoyage des installations pr√©c√©dentes
    await prepareServiceReinstall('dovecot', dovecotPackages, 'dovecot', onLog);

    // √âtape 1 : Installation des packages
    await runCommand('apt-get', ['update'], onLog);
    await runCommand('apt-get', ['install', '-y', ...dovecotPackages], onLog);

    // √âtape 2 : V√©rification et r√©g√©n√©ration des configs
    const mainConfigPath = '/etc/dovecot/dovecot.conf';
    const configExists = await regenerateConfigIfMissing(mainConfigPath, 'dovecot-core', onLog);

    if (!configExists) {
        // dpkg-reconfigure a √©chou√©, cr√©ation manuelle
        onLog(`   ‚ö†Ô∏è Cr√©ation manuelle de la configuration...\n`, 'stderr');

        const minimalConfig = `## Dovecot configuration file - Generated by ServerFlow
## Includes all conf.d files
!include_try /usr/share/dovecot/protocols.d/*.protocol
!include conf.d/*.conf
`;
        // S'assurer que les r√©pertoires existent
        if (!fs.existsSync('/etc/dovecot')) {
            fs.mkdirSync('/etc/dovecot', { recursive: true });
        }
        if (!fs.existsSync('/etc/dovecot/conf.d')) {
            fs.mkdirSync('/etc/dovecot/conf.d', { recursive: true });
        }

        fs.writeFileSync(mainConfigPath, minimalConfig);
        onLog(`   ‚úÖ Configuration minimale cr√©√©e\n`, 'stdout');

        // Relancer dpkg-reconfigure pour cr√©er les fichiers conf.d
        try {
            await runCommand('dpkg-reconfigure', ['-f', 'noninteractive', 'dovecot-core'], onLog);
        } catch { }
    }

    // V√©rifier √† nouveau que la config existe
    if (!fs.existsSync(mainConfigPath)) {
        throw new Error(`Configuration Dovecot manquante : ${mainConfigPath}`);
    }

    // √âtape 3 : Configuration personnalis√©e
    writeConfig('dovecot/local.conf', '/etc/dovecot/local.conf', {});

    // √âtape 4 : D√©marrage du service
    await runCommand('systemctl', ['enable', 'dovecot'], onLog);
    await runCommand('systemctl', ['restart', 'dovecot'], onLog);

    onLog(`‚úÖ Dovecot installed. IMAP on port 143/993, POP3 on 110/995\n`, 'stdout');
    return await getCommandVersion('dovecot', ['--version']) || 'installed';
}

/**
 * **installRspamd()** - Installe l'antispam Rspamd
 *
 * Cette fonction g√®re intelligemment les cas suivants :
 * - R√©installation apr√®s une d√©sinstallation
 * - Fichiers de configuration manquants apr√®s un purge
 */
export async function installRspamd(onLog: LogFn): Promise<string> {
    onLog(`üì• Installing Rspamd Antispam...\n`, 'stdout');

    // √âtape 0 : Nettoyage des installations pr√©c√©dentes
    await prepareServiceReinstall('rspamd', ['rspamd'], 'rspamd', onLog);

    await runCommand('apt-get', ['install', '-y', 'lsb-release', 'wget', 'gpg'], onLog);

    const codename = await runCommandSilent('lsb_release', ['-cs']);

    await runCommand('wget', ['-qO', '/tmp/rspamd.gpg.key', 'https://rspamd.com/apt-stable/gpg.key'], onLog);
    await runCommand('gpg', ['--batch', '--yes', '--dearmor', '-o', '/usr/share/keyrings/rspamd.gpg', '/tmp/rspamd.gpg.key'], onLog);

    const repoLine = `deb [signed-by=/usr/share/keyrings/rspamd.gpg] https://rspamd.com/apt-stable/ ${codename.trim()} main`;
    fs.writeFileSync('/etc/apt/sources.list.d/rspamd.list', repoLine + '\n');

    await runCommand('apt-get', ['update'], onLog);
    await runCommand('apt-get', ['install', '-y', 'rspamd', 'redis-server'], onLog);

    // Basic configuration for Postfix integration using template
    writeConfig('rspamd/worker-proxy.inc', '/etc/rspamd/local.d/worker-proxy.inc', {
        socket_path: '/var/spool/postfix/rspamd/rspamd.sock',
        socket_mode: '0666',
        socket_owner: '_rspamd'
    }, { createDirs: true });

    // Create socket directory
    if (!fs.existsSync('/var/spool/postfix/rspamd')) {
        fs.mkdirSync('/var/spool/postfix/rspamd', { recursive: true });
    }
    await runCommand('chown', ['_rspamd:_rspamd', '/var/spool/postfix/rspamd'], onLog);

    // Configure Postfix to use Rspamd
    await runCommand('postconf', ['-e', 'smtpd_milters = unix:/rspamd/rspamd.sock'], onLog);
    await runCommand('postconf', ['-e', 'non_smtpd_milters = unix:/rspamd/rspamd.sock'], onLog);
    await runCommand('postconf', ['-e', 'milter_default_action = accept'], onLog);

    await runCommand('systemctl', ['enable', 'rspamd'], onLog);
    await runCommand('systemctl', ['enable', 'redis-server'], onLog);
    await runCommand('systemctl', ['start', 'redis-server'], onLog);
    await runCommand('systemctl', ['start', 'rspamd'], onLog);

    onLog(`‚úÖ Rspamd installed. Web UI at http://localhost:11334\n`, 'stdout');
    onLog(`‚ö†Ô∏è Set password: rspamadm pw --encrypt\n`, 'stdout');
    return await getCommandVersion('rspamd', ['--version']) || 'installed';
}

/**
 * **installOpendkim()** - Installe OpenDKIM pour la signature des emails
 *
 * Cette fonction g√®re intelligemment les cas suivants :
 * - R√©installation apr√®s une d√©sinstallation
 * - Fichiers de configuration manquants apr√®s un purge
 *
 * @param onLog - Fonction de logging
 * @param mailConfig - Configuration mail optionnelle (domaine, hostname)
 */
export async function installOpendkim(onLog: LogFn, mailConfig?: { domain: string; hostname: string }): Promise<string> {
    onLog(`üì• Installing OpenDKIM...\n`, 'stdout');

    const opendkimPackages = ['opendkim', 'opendkim-tools'];

    // √âtape 0 : Nettoyage des installations pr√©c√©dentes
    await prepareServiceReinstall('opendkim', opendkimPackages, 'opendkim', onLog);

    await runCommand('apt-get', ['update'], onLog);
    await runCommand('apt-get', ['install', '-y', ...opendkimPackages], onLog);

    // Utiliser la config fournie ou d√©duire du hostname syst√®me
    let hostname: string;
    let domain: string;

    if (mailConfig) {
        hostname = mailConfig.hostname;
        domain = mailConfig.domain;
        onLog(`   üìß Using configured domain: ${domain}\n`, 'stdout');
    } else {
        hostname = os.hostname();
        domain = hostname.includes('.') ? hostname.split('.').slice(1).join('.') : hostname;
    }

    // Create directories
    const keysDir = `/etc/opendkim/keys/${domain}`;
    if (!fs.existsSync(keysDir)) {
        fs.mkdirSync(keysDir, { recursive: true });
    }

    // Generate DKIM keys
    onLog(`üîê Generating DKIM keys for ${domain}...\n`, 'stdout');
    await runCommand('opendkim-genkey', ['-b', '2048', '-d', domain, '-D', keysDir, '-s', 'default', '-v'], onLog);
    await runCommand('chown', ['-R', 'opendkim:opendkim', '/etc/opendkim'], onLog);
    await runCommand('chmod', ['600', `${keysDir}/default.private`], onLog);

    // Configure OpenDKIM using templates
    const templateVars = { hostname, domain, keys_dir: keysDir };

    writeConfig('opendkim/opendkim.conf', '/etc/opendkim.conf', templateVars);
    writeConfig('opendkim/TrustedHosts', '/etc/opendkim/TrustedHosts', templateVars);
    writeConfig('opendkim/KeyTable', '/etc/opendkim/KeyTable', templateVars);
    writeConfig('opendkim/SigningTable', '/etc/opendkim/SigningTable', templateVars);

    // Configure Postfix to use OpenDKIM
    await runCommand('postconf', ['-e', 'milter_protocol = 6'], onLog);
    await runCommand('postconf', ['-e', 'milter_default_action = accept'], onLog);
    await runCommand('postconf', ['-e', 'smtpd_milters = inet:localhost:12301'], onLog);
    await runCommand('postconf', ['-e', 'non_smtpd_milters = inet:localhost:12301'], onLog);

    await runCommand('systemctl', ['enable', 'opendkim'], onLog);
    await runCommand('systemctl', ['start', 'opendkim'], onLog);

    // Show the DNS record
    const dkimPublicKey = fs.readFileSync(`${keysDir}/default.txt`, 'utf-8');
    onLog(`\nüìã Add this DNS TXT record for DKIM:\n${dkimPublicKey}\n`, 'stdout');

    return 'installed';
}

/**
 * **installClamav()** - Installe l'antivirus ClamAV
 *
 * Cette fonction g√®re intelligemment les cas suivants :
 * - R√©installation apr√®s une d√©sinstallation (nettoie les fichiers corrompus)
 * - Rate-limiting du CDN ClamAV (erreur 429)
 * - Absence de d√©finitions de virus (main.cvd, daily.cvd)
 * - Service rspamd masqu√© ou absent
 * - Fichiers syst√®me corrompus avec CRLF (Windows line endings)
 * - Utilisateur/groupe clamav corrompu avec \r
 */
export async function installClamav(onLog: LogFn): Promise<string> {
    onLog(`üì• Installing ClamAV antivirus...\n`, 'stdout');

    // ============================================
    // √âTAPE 0 : Nettoyage COMPLET des corruptions CRLF
    // ============================================
    // Les fichiers peuvent contenir des \r (Windows line endings) qui cassent tout
    onLog(`üîß Nettoyage des fichiers corrompus (CRLF)...\n`, 'stdout');

    // 1. Fichiers syst√®me (/etc/passwd, /etc/group, etc.)
    const systemFiles = ['/etc/passwd', '/etc/group', '/etc/shadow', '/etc/gshadow'];

    // 2. Fichier statoverride de dpkg (CRITIQUE - peut contenir "clamav\r")
    const statoverrideFile = '/var/lib/dpkg/statoverride';
    if (fs.existsSync(statoverrideFile)) {
        try {
            const content = fs.readFileSync(statoverrideFile, 'utf-8');
            // Supprimer les lignes contenant "clamav" (corrompues ou non)
            // car on va recr√©er l'utilisateur proprement
            const lines = content.split('\n');
            const cleanedLines = lines.filter(line => !line.includes('clamav'));
            if (lines.length !== cleanedLines.length) {
                onLog(`   üîß Nettoyage de ${statoverrideFile} (suppression entr√©es clamav)\n`, 'stdout');
                fs.writeFileSync(statoverrideFile, cleanedLines.join('\n'));
            }
        } catch { }
    }

    // 3. Scripts dpkg de clamav - SUPPRIMER COMPL√àTEMENT (pas juste nettoyer)
    // Ces scripts peuvent contenir des r√©f√©rences corrompues
    const dpkgInfoDir = '/var/lib/dpkg/info';
    if (fs.existsSync(dpkgInfoDir)) {
        try {
            const files = fs.readdirSync(dpkgInfoDir);
            let deletedCount = 0;
            for (const file of files) {
                if (file.startsWith('clamav')) {
                    const filePath = `${dpkgInfoDir}/${file}`;
                    try {
                        fs.unlinkSync(filePath);
                        deletedCount++;
                    } catch { }
                }
            }
            if (deletedCount > 0) {
                onLog(`   üóëÔ∏è Suppression de ${deletedCount} fichiers dpkg info clamav\n`, 'stdout');
            }
        } catch { }
    }

    // 4. Nettoyer le fichier dpkg status (supprimer les entr√©es clamav corrompues)
    const dpkgStatusFile = '/var/lib/dpkg/status';
    if (fs.existsSync(dpkgStatusFile)) {
        try {
            const content = fs.readFileSync(dpkgStatusFile, 'utf-8');
            if (content.includes('\r')) {
                onLog(`   üîß Correction CRLF dans dpkg status\n`, 'stdout');
                const fixed = content.replace(/\r\n/g, '\n').replace(/\r/g, '');
                fs.writeFileSync(dpkgStatusFile, fixed);
                systemFiles.push(dpkgStatusFile);
            }
        } catch { }
    }

    // 5. Fichiers de configuration debconf
    const debconfFiles = [
        '/var/cache/debconf/config.dat',
        '/var/cache/debconf/passwords.dat',
        '/var/cache/debconf/templates.dat'
    ];
    systemFiles.push(...debconfFiles);

    let filesFixed = 0;

    for (const filePath of systemFiles) {
        if (fs.existsSync(filePath)) {
            try {
                const content = fs.readFileSync(filePath, 'utf-8');
                if (content.includes('\r')) {
                    onLog(`   üîß Correction: ${filePath}\n`, 'stdout');
                    const fixedContent = content.replace(/\r\n/g, '\n').replace(/\r/g, '');
                    fs.writeFileSync(filePath, fixedContent);
                    filesFixed++;
                }
            } catch {
                // Ignorer les fichiers qu'on ne peut pas lire/√©crire
            }
        }
    }

    if (filesFixed > 0) {
        onLog(`   ‚úÖ ${filesFixed} fichier(s) corrig√©(s)\n`, 'stdout');
    } else {
        onLog(`   ‚úÖ Aucun fichier corrompu trouv√©\n`, 'stdout');
    }

    // ============================================
    // √âTAPE 0b : Purge TOTALE de toute trace de ClamAV
    // ============================================
    // On purge TOUJOURS, m√™me si le package semble OK, pour √©viter les probl√®mes
    onLog(`üßπ Purge compl√®te de ClamAV (si pr√©sent)...\n`, 'stdout');

    // Arr√™ter les services
    try { await runCommandSilent('systemctl', ['stop', 'clamav-daemon']); } catch { }
    try { await runCommandSilent('systemctl', ['stop', 'clamav-freshclam']); } catch { }

    // Supprimer l'utilisateur/groupe clamav s'ils existent (y compris corrompus)
    // On utilise sed pour supprimer directement des fichiers passwd/group
    // car userdel/groupdel peuvent √©chouer si le nom contient \r
    try {
        await runCommandSilent('bash', ['-c', "sed -i '/^clamav/d' /etc/passwd /etc/shadow /etc/group /etc/gshadow 2>/dev/null || true"]);
    } catch { }

    // Forcer la suppression des packages (ignorer les erreurs)
    const clamavPkgs = ['clamav-daemon', 'clamav-freshclam', 'clamav', 'clamav-base', 'clamdscan', 'libclamav11'];
    for (const pkg of clamavPkgs) {
        try {
            await runCommandSilent('dpkg', ['--purge', '--force-all', pkg]);
        } catch { }
    }

    // Nettoyer les fichiers r√©siduels
    try { await runCommandSilent('rm', ['-rf', '/var/lib/clamav']); } catch { }
    try { await runCommandSilent('rm', ['-rf', '/var/run/clamav']); } catch { }
    try { await runCommandSilent('rm', ['-rf', '/var/log/clamav']); } catch { }
    try { await runCommandSilent('rm', ['-rf', '/etc/clamav']); } catch { }

    // Nettoyer le cache apt
    try { await runCommandSilent('apt-get', ['clean']); } catch { }

    onLog(`   ‚úÖ Purge termin√©e\n`, 'stdout');

    // ============================================
    // √âTAPE 1 : Nettoyage pr√©-installation
    // ============================================
    const clamavDataDir = '/var/lib/clamav';
    const mirrorsFile = `${clamavDataDir}/mirrors.dat`;

    if (fs.existsSync(mirrorsFile)) {
        onLog(`üßπ Nettoyage du fichier mirrors.dat (reset rate-limiting)...\n`, 'stdout');
        try { fs.unlinkSync(mirrorsFile); } catch { }
    }

    // ============================================
    // √âTAPE 2 : Purge du cache debconf corrompu
    // ============================================
    // Le cache debconf peut contenir des r√©f√©rences √† "clamav\r" corrompues
    // qui causent des erreurs pendant "Preconfiguring packages"
    onLog(`üßπ Purge du cache debconf ClamAV...\n`, 'stdout');

    // Purger les configurations debconf de clamav
    const clamavPackages = ['clamav', 'clamav-daemon', 'clamav-freshclam', 'clamav-base', 'clamdscan'];
    for (const pkg of clamavPackages) {
        try {
            await runCommandSilent('bash', ['-c', `echo PURGE | debconf-communicate ${pkg}`]);
        } catch { }
    }

    // Supprimer aussi les fichiers de cache debconf corrompus
    const debconfDir = '/var/cache/debconf';
    if (fs.existsSync(debconfDir)) {
        for (const filename of ['config.dat', 'passwords.dat', 'templates.dat']) {
            const filePath = `${debconfDir}/${filename}`;
            if (fs.existsSync(filePath)) {
                try {
                    const content = fs.readFileSync(filePath, 'utf-8');
                    if (content.includes('clamav') && content.includes('\r')) {
                        onLog(`   üîß Nettoyage CRLF dans ${filename}\n`, 'stdout');
                        const fixed = content.replace(/\r/g, '');
                        fs.writeFileSync(filePath, fixed);
                    }
                } catch { }
            }
        }
    }

    onLog(`   ‚úÖ Cache debconf purg√©\n`, 'stdout');

    // ============================================
    // √âTAPE 3 : Cr√©ation de l'utilisateur clamav
    // ============================================
    // On cr√©e l'utilisateur NOUS-M√äMES avant l'installation pour √©viter
    // les probl√®mes avec les scripts post-installation corrompus
    onLog(`üë§ Cr√©ation de l'utilisateur clamav...\n`, 'stdout');

    // Supprimer tout utilisateur/groupe clamav existant (potentiellement corrompu)
    try { await runCommandSilent('userdel', ['-f', 'clamav']); } catch { }
    try { await runCommandSilent('groupdel', ['clamav']); } catch { }

    // Cr√©er le groupe clamav
    try {
        await runCommand('groupadd', ['--system', 'clamav'], onLog);
    } catch {
        // Le groupe existe peut-√™tre d√©j√†
    }

    // Cr√©er l'utilisateur clamav
    try {
        await runCommand('useradd', [
            '--system',
            '--no-create-home',
            '--shell', '/usr/sbin/nologin',
            '--gid', 'clamav',
            '--comment', 'ClamAV Antivirus',
            'clamav'
        ], onLog);
    } catch {
        // L'utilisateur existe peut-√™tre d√©j√†
    }

    // Ajouter clamav au groupe adm pour les logs
    try { await runCommandSilent('usermod', ['-aG', 'adm', 'clamav']); } catch { }

    onLog(`   ‚úÖ Utilisateur clamav cr√©√©\n`, 'stdout');

    // ============================================
    // √âTAPE 4 : Installation des packages
    // ============================================
    await runCommand('apt-get', ['update'], onLog);

    try {
        await runCommand('apt-get', ['install', '-y', 'clamav', 'clamav-daemon', 'clamav-freshclam'], onLog);
    } catch (installErr: any) {
        onLog(`‚ö†Ô∏è Installation √©chou√©e, tentative de r√©cup√©ration...\n`, 'stderr');

        // Reconfigurer les packages cass√©s
        try {
            await runCommand('dpkg', ['--configure', '-a'], onLog);
        } catch { }

        // R√©parer les d√©pendances
        try {
            await runCommand('apt-get', ['install', '-f', '-y'], onLog);
        } catch { }

        // V√©rifier si l'installation a finalement r√©ussi
        try {
            const dpkgCheck = await runCommandSilent('dpkg', ['-s', 'clamav-daemon']);
            if (!dpkgCheck.includes('Status: install ok configured')) {
                throw new Error('Package not configured');
            }
        } catch {
            throw new Error(`Installation ClamAV √©chou√©e: ${installErr.message}`);
        }
    }

    // ============================================
    // √âTAPE 5 : Mise √† jour des d√©finitions de virus
    // ============================================
    // Stop freshclam (le service) pour pouvoir lancer freshclam manuellement
    try {
        await runCommandSilent('systemctl', ['stop', 'clamav-freshclam']);
    } catch { }

    onLog(`ü¶† Mise √† jour des d√©finitions de virus...\n`, 'stdout');

    let freshclamSuccess = false;
    let rateLimited = false;

    try {
        // Lancer freshclam et capturer la sortie
        await runCommand('freshclam', [], onLog);
        freshclamSuccess = true;
    } catch (err: any) {
        // V√©rifier si c'est un rate-limiting (erreur 429)
        const errorMsg = err.message || '';
        if (errorMsg.includes('429') || errorMsg.includes('rate limit') || errorMsg.includes('cool-down')) {
            rateLimited = true;
            onLog(`‚ö†Ô∏è Rate-limiting ClamAV CDN d√©tect√©.\n`, 'stderr');
            onLog(`   Le serveur ClamAV limite les t√©l√©chargements trop fr√©quents.\n`, 'stderr');
            onLog(`   Les d√©finitions seront t√©l√©charg√©es automatiquement plus tard.\n`, 'stderr');
        } else {
            onLog(`‚ö†Ô∏è √âchec de freshclam: ${errorMsg}\n`, 'stderr');
        }
    }

    // ============================================
    // √âTAPE 6 : V√©rification des d√©finitions
    // ============================================
    // ClamAV daemon ne peut pas d√©marrer sans au moins main.cvd ou daily.cvd
    const mainCvd = `${clamavDataDir}/main.cvd`;
    const dailyCvd = `${clamavDataDir}/daily.cvd`;
    const hasDefinitions = fs.existsSync(mainCvd) || fs.existsSync(dailyCvd);

    if (!hasDefinitions) {
        onLog(`‚ö†Ô∏è Aucune d√©finition de virus disponible.\n`, 'stderr');
        if (rateLimited) {
            onLog(`   Le daemon ClamAV ne pourra pas d√©marrer tant que les d√©finitions\n`, 'stderr');
            onLog(`   ne seront pas t√©l√©charg√©es. R√©essayez dans quelques heures.\n`, 'stderr');
        }
    }

    // ============================================
    // √âTAPE 7 : Configuration du daemon
    // ============================================
    writeConfig('clamav/clamd.conf', '/etc/clamav/clamd.conf', {});

    // Cr√©er le r√©pertoire de socket s'il n'existe pas
    const socketDir = '/var/run/clamav';
    if (!fs.existsSync(socketDir)) {
        fs.mkdirSync(socketDir, { recursive: true });
        await runCommandSilent('chown', ['clamav:clamav', socketDir]);
    }

    // ============================================
    // √âTAPE 8 : Activation des services
    // ============================================
    await runCommand('systemctl', ['enable', 'clamav-freshclam'], onLog);
    await runCommand('systemctl', ['start', 'clamav-freshclam'], onLog);

    await runCommand('systemctl', ['enable', 'clamav-daemon'], onLog);

    // Tenter de d√©marrer le daemon uniquement si on a des d√©finitions
    let daemonStarted = false;
    if (hasDefinitions) {
        try {
            await runCommand('systemctl', ['start', 'clamav-daemon'], onLog);

            // Attendre un peu et v√©rifier si le daemon est vraiment d√©marr√©
            await new Promise(resolve => setTimeout(resolve, 2000));
            const status = await runCommandSilent('systemctl', ['is-active', 'clamav-daemon']);
            daemonStarted = status.trim() === 'active';
        } catch {
            daemonStarted = false;
        }
    } else {
        onLog(`‚è≠Ô∏è D√©marrage du daemon ClamAV diff√©r√© (pas de d√©finitions)\n`, 'stdout');
    }

    // ============================================
    // √âTAPE 9 : Int√©gration Rspamd (si disponible)
    // ============================================
    const rspamdClamavDir = '/etc/rspamd/local.d';
    if (fs.existsSync(rspamdClamavDir)) {
        writeConfig('rspamd/antivirus.conf', `${rspamdClamavDir}/antivirus.conf`, {});

        // V√©rifier si rspamd est actif (pas masqu√©) avant de recharger
        try {
            const rspamdStatus = await runCommandSilent('systemctl', ['is-enabled', 'rspamd']);
            if (rspamdStatus.trim() === 'enabled') {
                await runCommand('systemctl', ['reload', 'rspamd'], onLog);
            }
        } catch {
            // rspamd n'est pas disponible, on ignore silencieusement
        }
    }

    // ============================================
    // √âTAPE 10 : R√©sum√© de l'installation
    // ============================================
    onLog(`\n`, 'stdout');
    if (daemonStarted) {
        onLog(`‚úÖ ClamAV install√© et op√©rationnel!\n`, 'stdout');
    } else if (hasDefinitions) {
        onLog(`‚ö†Ô∏è ClamAV install√© mais le daemon n'a pas d√©marr√©.\n`, 'stdout');
        onLog(`   V√©rifiez les logs: journalctl -u clamav-daemon\n`, 'stdout');
    } else if (rateLimited) {
        onLog(`‚ö†Ô∏è ClamAV install√© mais en attente de d√©finitions (rate-limiting).\n`, 'stdout');
        onLog(`   Le daemon d√©marrera automatiquement apr√®s t√©l√©chargement.\n`, 'stdout');
    } else {
        onLog(`‚ö†Ô∏è ClamAV install√© mais sans d√©finitions de virus.\n`, 'stdout');
    }
    onLog(`üìã Les d√©finitions seront mises √† jour automatiquement via freshclam.\n`, 'stdout');

    // Retourner un statut appropri√©
    if (daemonStarted) {
        return 'installed';
    } else if (hasDefinitions) {
        return 'installed (daemon not running)';
    } else {
        return 'installed (no definitions)';
    }
}

/**
 * **installSpfPolicyd()** - Installe le SPF Policy Daemon
 */
export async function installSpfPolicyd(onLog: LogFn): Promise<string> {
    onLog(`üì• Installing SPF Policy Daemon...\n`, 'stdout');

    await runCommand('apt-get', ['update'], onLog);
    await runCommand('apt-get', ['install', '-y', 'postfix-policyd-spf-python'], onLog);

    // Configure Postfix to use SPF policy daemon using template
    const masterCfPath = '/etc/postfix/master.cf';
    if (fs.existsSync(masterCfPath)) {
        const masterCf = fs.readFileSync(masterCfPath, 'utf-8');

        // Check if SPF policy is already configured
        if (!masterCf.includes('policyd-spf')) {
            writeConfig('postfix/master.cf.spf', masterCfPath, {}, { append: true });
            onLog(`‚úÖ Added SPF policy daemon to master.cf\n`, 'stdout');
        }
    }

    // Configure main.cf to use SPF check
    await runCommand('postconf', ['-e', 'policyd-spf_time_limit = 3600'], onLog);

    // Get current smtpd_recipient_restrictions and add SPF check
    try {
        const currentRestrictions = await runCommandSilent('postconf', ['smtpd_recipient_restrictions']);
        const restrictionsValue = currentRestrictions.split('=')[1]?.trim() || '';

        if (!restrictionsValue.includes('check_policy_service unix:private/policyd-spf')) {
            let newRestrictions = restrictionsValue;
            if (restrictionsValue) {
                newRestrictions = `${restrictionsValue}, check_policy_service unix:private/policyd-spf`;
            } else {
                newRestrictions = 'permit_sasl_authenticated, permit_mynetworks, reject_unauth_destination, check_policy_service unix:private/policyd-spf';
            }
            await runCommand('postconf', ['-e', `smtpd_recipient_restrictions = ${newRestrictions}`], onLog);
        }
    } catch {
        await runCommand('postconf', ['-e', 'smtpd_recipient_restrictions = permit_sasl_authenticated, permit_mynetworks, reject_unauth_destination, check_policy_service unix:private/policyd-spf'], onLog);
    }

    await runCommand('systemctl', ['reload', 'postfix'], onLog);

    onLog(`‚úÖ SPF Policy Daemon installed and configured!\n`, 'stdout');
    onLog(`üìã SPF checks are now enabled for incoming emails\n`, 'stdout');
    onLog(`üí° Make sure you have a valid SPF record in your DNS:\n`, 'stdout');
    onLog(`   TXT record: v=spf1 mx a ~all\n`, 'stdout');

    return 'installed';
}
